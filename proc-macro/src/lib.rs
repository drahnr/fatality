use proc_macro2::TokenStream;
use quote::ToTokens;

mod types;

pub use self::types::*;

fn fatality2(
    attr: proc_macro2::TokenStream,
    input: proc_macro2::TokenStream,
) -> proc_macro2::TokenStream {
    let item = match syn::parse2::<syn::Item>(input.clone()) {
        Err(err) => {
            let mut bail = input.into_token_stream();
            bail.extend(err.to_compile_error());
            return bail;
        }
        Ok(syn::Item::Enum(item)) => item,
        Ok(item) => {
            let mut bail = input.into_token_stream();
            let err = syn::Error::new(
                item.span(),
                "Only `enum`-types are currently supported",
            );
            bail.extend(err.to_compile_error());
            return bail;
        }
    };

    let mut res = TokenStream::new();

    let attr = match syn::parse2::<Attr>(attr) {
        Ok(attr) => attr,
        Err(e) => {
            res.extend(e.to_compile_error());
            Attr::Empty
        }
    };
    res.extend(fatality_gen(attr, item).unwrap_or_else(|e| e.to_compile_error()));

    expander::Expander::new("fatality")
        .add_comment("Generated by `#[fatality::fatality]`".to_owned())
        // .fmt(expander::Edition::_2021)
        .dry(!cfg!(feature = "expand"))
        .write_to_out_dir(res)
        .unwrap()
}

#[proc_macro_attribute]
pub fn fatality(
    attr: proc_macro::TokenStream,
    input: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    let attr = TokenStream::from(attr);
    let input = TokenStream::from(input);

    let output: TokenStream = fatality2(attr, input);

    proc_macro::TokenStream::from(output)
}

#[cfg(test)]
mod tests;
